# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:22:39+00:00



import argparse
import json
import os
from datetime import datetime as datetime_aliased
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity, HTTPBasic
from fastapi import Header, UploadFile
from pydantic import constr

from models import (
    AggregationPipelinePost,
    APIKeyModel,
    APIKeyRequest,
    AuthApiKeyGetResponse,
    AuthApiKeyInboxInboxIdGetResponse,
    AuthModel,
    ChangePasswordModelPost,
    ConnectionModelGet,
    ConnectionModelPost,
    ConnectionsGetResponse,
    CustomOutputPost,
    DashboardSettingsModelGet,
    DashboardSettingsModelPatch,
    DataRetentionModel,
    DataRetentionModelPatch,
    DataRetentionSettingsGetResponse,
    DeliveryMethod1,
    Dictionary,
    DocumentIds,
    DocumentModelGet,
    DocumentTypeModelGet,
    EnrichmentModelPost,
    FormatModelGet,
    FormatModelPatch,
    FormatModelPost,
    How,
    InboxesGetResponse,
    InboxesInboxIdDocumentsGetResponse,
    InboxesInboxIdPaginatedGetResponse,
    InboxModelGet,
    InboxModelPatch,
    InboxModelPost,
    IntegrationModelGet,
    PredictorModelGet,
    PredictorSettingModel,
    PredictorSettingsGetResponse,
    ProjectModelPatch,
    ProjectModelPost,
    ReportModelFullGenerate,
    ReportModelGet,
    ReportModelPost,
    ReportsGetResponse,
    ResetPasswordModelPost,
    Reviewer,
    ReviewSettingsModelGet,
    ReviewSettingsModelPatch,
    RoleModelGet,
    RoleModelPatch,
    RoleModelPost,
    RolesGetResponse,
    RuleConfigGetResponse,
    RuleConfigModel,
    RuleConfigModelGet,
    SamplingModelGet,
    SamplingModelPatch,
    SamplingSettingsGetResponse,
    SettingThresholdModelGet,
    SettingThresholdModelPatch,
    SsoConfigModel,
    SsoConfigModelGet,
    SsoModel,
    StatusDataPost,
    TableAnnotationPost,
    TagFieldModelGet,
    TenantModelGet,
    TenantModelPatch,
    ThresholdSettingsGetResponse,
    TokenModelBase,
    TokenReplyModel,
    UserModelGet,
    UserModelPatch,
    UserModelPost,
    UsersGetResponse,
    VersionCompare,
    VersionPost,
    What1,
    WorkflowModel,
)

app = MCPProxy(
    description='This OpenAPI describes the API exposed by the contract.fit backend.\n\n## Security\n\n### Authentication\n\nAll endpoints are protected: you need to make authenticated calls. There are 3 authentication mechanisms:\n- HTTP Basic (Username + Password)\n- JWT Token\n- API-Key\n\nBy default you should have an account allowing you to bootstrap your tenant and create users and roles, using Basic Auth or after creating a Token  - see */auth* endpoints.\n\nIf you are missing credentials or permissions, please [contact us](https://contract.fit/contact-us).\n\n### Authorization\n\nThe security system is RBAC based: users must be granted scoped roles, allowing them to access resources.\nEach role grants a defined set of permissions, which can be restricted to a given inbox or document - see */roles* endpoints.\n\n## Upload and Processing\n\nBelow is a short description of common use cases of the API.\n\n### Simple Upload\n\nThe easiest and simplest way to get started is to use POST /documents : it will make a synchronous upload of your file and wait for the result.\n\nThis is a simplified version of POST /documents/{inbox_id} with less arguments and settings; it may not be suitable for real workload as it offers less capabilities.\n\n### Upload to Inbox\n\nThe favored endpoint to upload files is POST /documents/{inbox_id}: it is also highly recommended to make async call using sync=false.\n\n**Sync / Async**\n\nFor convenience uploads can be synchronous: it will make the request blocks until the document is processed.\n\nIt is however discouraged to rely on sync requests, as our service is designed to process documents asynchronously. You might run into timeouts and unprocessed document depending on factors such as server load and number of pending documents.\n\nAsynchronous calls will only schedule the processing and directly return the document ID without waiting: the document will be processed as soon as possible. You can then wait for the processed result using GET */documents/{document_id}*.\n\n### Reprocessing\n\nYou can reprocess a document using POST */documents/{document_id}/reprocess* : it will schedule an async processing of the document (note: it is not possible to make a sync reprocessing)\n',
    title='Contract.fit API',
    version='1.0',
    servers=[{'url': '//cfportal.contract-p.fit/api'}],
)


@app.get(
    '/about/release_notes',
    tags=['authentication_management', 'user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_release_notes():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/about/version',
    tags=['authentication_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_version():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth',
    description=""" Login with the provided credentials (POST data) and return a JWT Token for this user. """,
    tags=['authentication_management', 'oauth_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_auth(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), body: AuthModel = ...
):
    """
    Login and retrieve a JWT Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/auth/api-key',
    description=""" **Permission required:** view_api_keys """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_keys_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get all API-Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/api-key',
    description=""" API Keys are simple randomly generated strings bound to roles that grant access to resources.

Every API Key maps to attributes defining its validity and can be revoked at any time.

API Key can be passed in the **X-API-Key** HTTP Header and in the querystring **&api_key=**


**Permission required:** edit_backend_settings """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_api_keys_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), body: APIKeyRequest = ...
):
    """
    Create a new API Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/auth/api-key/inbox/{inbox_id}',
    description=""" **Permission required:** view_api_keys """,
    tags=['api_key_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_keys_inbox_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), inbox_id: str = ...
):
    """
    Get all API-Keys for this inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/api-key/inbox/{inbox_id}',
    description=""" The requesting user needs to have inbox level permissions

API Keys are simple randomly generated strings bound to roles that grant access to resources.

Every API Key maps to attributes defining its validity and can be revoked at any time.

API Key can be passed in the **X-API-Key** HTTP Header and in the querystring **&api_key=**


**Permission required:** edit_backend_settings """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_api_keys_inbox_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    inbox_id: str = ...,
    body: APIKeyRequest = ...,
):
    """
    Create a new API Key on inbox level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/auth/api-key/{key}',
    description=""" Completely remove an API Key, thus disabling it. The token won't be recoverable

**Permission required:** edit_backend_settings """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_api_key_resource(key: str):
    """
    Delete an API Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/auth/api-key/{key}',
    description=""" **Permission required:** view_api_keys """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_key_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), key: str = ...
):
    """
    Get details of an API-Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/auth/api-key/{key}',
    description=""" **roles** can't be modified after creation: you need to create a new token if you want other roles.

**Permission required:** edit_backend_settings """,
    tags=['api_key_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_api_key_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), key: str = ...
):
    """
    Edit an API-Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/ephemeral',
    description=""" Ephemeral tokens are short lived tokens that can be used to temporary grant access to resources. """,
    tags=['authentication_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_ephemeral_token_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Create a new ephemeral token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/get_JWT',
    description=""" ## This endpoint is *deprecated* : use /auth/ephemeral and /auth/token instead

This endpoint requires authentication and requires the user to have the role **edit_users**: you can
then request a JWT on behalf of another user, specified in the request **username** attribute.

This endpoint has 2 modes depending on the presence or absence of the *roles* attribute in the request
data:

## Regular token

When sending only a **username**: a regular JWT Token bound to the given user is created and returned.

## Temporary token

When sending **username** AND a list **roles** of **role** (defined by the UID, optional the inbox to restrict access to):
a temporary token is created that will behave like a regular user with the given roles until the access token expires.

**Permission required:** edit_users """,
    tags=['authentication_management', 'oauth_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_get_jwt_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: TokenModelBase = ...,
):
    """
    Create a new JWT Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/reset_password',
    tags=['authentication_management', 'user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_reset_password(body: ResetPasswordModelPost):
    """
    Reset the user password
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/token',
    description=""" Bearer tokens can be used to authenticated without session or without sending credentials.

If the user making the request has sufficient privileges, he is allowed to create a token on behalf of another user.
Otherwise only a token for the request current user is allowed.


**Permission required:** edit_users """,
    tags=['authentication_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_token_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: TokenModelBase = ...,
):
    """
    Create a new token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections',
    description=""" Return the list of set up connections

**Permission required:** edit_integrations """,
    tags=['connection_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_connections_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get all Connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/connections',
    description=""" Create a new connection bound to the given scope (can be a project or inbox)

**Permission required:** edit_integrations """,
    tags=['connection_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_connections_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: ConnectionModelPost = ...,
):
    """
    Create connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/connections/{connection_id}',
    description=""" Delete the given connection.

**WARNING** This will completely remove the connection, this is not recoverable

**Permission required:** edit_integrations """,
    tags=['connection_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_connection_resource(connection_id: str):
    """
    Delete a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections/{connection_id}',
    description=""" Return the connection attributes

**Permission required:** edit_integrations """,
    tags=['connection_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_connection_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), connection_id: str = ...
):
    """
    Get connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/connections/{connection_id}',
    description=""" attributes

**Permission required:** edit_integrations """,
    tags=['connection_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_connection_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    connection_id: str = ...,
    body: ConnectionModelPost = ...,
):
    """
    Update connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data_retention_settings',
    description=""" **Permission required:** read_data_retention_settings """,
    tags=['data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_retention_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get all data retention settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/data_retention_settings/{level}/{id}',
    description=""" **Permission required:** edit_data_retention_settings """,
    tags=['sampling_setting_management', 'data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_data_retention_resource(level: str, id: str = ...):
    """
    Delete scoped sampling settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data_retention_settings/{level}/{id}',
    description=""" **Permission required:** read_data_retention_settings """,
    tags=['data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_retention_settings__level__id(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    level: str = ...,
    id: str = ...,
):
    """
    Get scoped data retention settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/data_retention_settings/{level}/{id}',
    description=""" **Permission required:** edit_data_retention_settings """,
    tags=['data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_data_retention_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    level: str = ...,
    id: str = ...,
    body: DataRetentionModelPatch = ...,
):
    """
    Update scoped data retention settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/',
    description=""" This endpoint is a simplified version of the upload document to inbox one - synchronous mode.

The upload file will be upload to the given inbox if provided, else fallback to the **invoice** inbox.
The file will be processed synchronously, ie the request will blocks until the document was processed
*or* until it timeout; in this case the document might **not** be correctly processed.


For a more reliable processing use the /documents/{inbox_id} endpoint in async mode


**Permission required:** upload """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_simple_documents_resource(file: UploadFile):
    """
    Upload a new document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/custom_output',
    description=""" Using the provided filter on documents, will generate a custom output.

**Note:** only excel output is supported at the moment.

**Permission required:** review """,
    tags=['document_management', 'format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_custom_output_resource(body: CustomOutputPost):
    """
    Generate custom output for documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/enrich',
    tags=['user_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_enrichment_resource(body: EnrichmentModelPost):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/file_query/{data_type}',
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_data_resource(data_type: str = 'document', body: DocumentIds = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/query/{query_type}',
    tags=['user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_query(query_type: str, body: AggregationPipelinePost = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/documents/{document_id}',
    description=""" how parameter: if how == "FULL", we delete the entire document, including its source files
if how == "SOURCE_FILES", we only remove the (source) files and we set the archived flag. In practice this means
all information in the database (json) remains available, but you can no longer download / visualise the original document.

**WARNING** The removal (of source files and in the database) is permanent


**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_document_delete_resource(
    how: Optional[How] = 'predicted', document_id: str = ...
):
    """
    Delete the document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}',
    description=""" Simple endpoint that will fetch the given document

**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_delete_resource(document_id: str):
    """
    Get the document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{document_id}/compare_versions',
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_compare_versions_resource(
    document_id: str, body: VersionCompare = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/custom_output',
    description=""" If you have a custom output configured (this is set by contract.fit team), This allows you to
get the custom output formatted document.


**Permission required:** review """,
    tags=['document_management', 'format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_transform_resource(document_id: str):
    """
    Get custom output formatted document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{document_id}/feedback',
    description=""" Send a feedback for the given document and optionally evaluate.

When a document is to be reviewed, this endpoint is used to send the user feedback.

**Permission required:** submit """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_submit_eval_resource(document_id: str, body: VersionPost = ...):
    """
    Submit a feedback
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/last_version',
    description=""" Get the latest possible version for this document, optionally with constraints on the source or name

**Permission required:** review """,
    tags=['document_management', 'release_and_version_info'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_last_version_resource(
    name: Optional[str] = None,
    source: Optional[str] = None,
    is_evaluated: Optional[bool] = False,
    document_id: str = ...,
):
    """
    Get latest version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/original_file',
    description=""" Return the document original file, as attachment.

**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_original_file_resource(document_id: str):
    """
    Get document original file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/page/{page_range}',
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_page_image_resource(page_range: str, document_id: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/page_thumbnail/{page_range}',
    tags=['document_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_page_image_thumbnail_resource(document_id: str, page_range: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{document_id}/process_table_annotation',
    description=""" A fast and convenient annotation tool that converts a table-level annotation to cell-level feedback.

**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_process_table_annotation(
    document_id: str, body: TableAnnotationPost = ...
):
    """
    Process a table-level annotation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{document_id}/reprocess',
    description=""" This endpoint schedules (async) reprocessing for the given document;
it will call the async processing with the given desired version name,
similar to the async document upload but skipping OCR.
It works asynchronously, so results need to be consulted by a separate call (or webhook)


**Permission required:** upload """,
    tags=['inbox_management', 'document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_reprocess_document_resource(
    name: Optional[str] = 'reprocessed',
    reviewer: Optional[Reviewer] = 'Machine',
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    document_id: str = ...,
):
    """
    Schedule document reprocessing
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/reverse/{page_range}',
    tags=['document_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_reverse_resource(page_range: str, document_id: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{document_id}/status_data',
    description=""" Update the given document status data with the request user and date.

Each document defines some status:
- lock
- escalate
- reject
- delete
- archive
- submitted

These fields have 3 attributes:
- status true / false
- since: datetime (UTC)
- by: user ID

By calling this endpoint you can update the given status data with the request user
(the one authenticated) and the current datetime.
**Note** : You cannot pass a user in the request nor a datetime

**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_document_status_data_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    document_id: str = ...,
    body: StatusDataPost = ...,
):
    """
    Update document status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/text',
    description=""" Return the optimal text for the document; will either be the OCR text, the native text,
the raw text or a translated version.

To ease the data volume from the DB, we lazy load only the relevant text for the document.

**Permission required:** review """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_text_resource(document_id: str):
    """
    Get the document text
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}/workflow',
    description=""" **WARNING experimental use only**


**Permission required:** upload """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_document_workflow_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), document_id: str = ...
):
    """
    Get the document Workflow
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents/{inbox_id}',
    description=""" This endpoint uploads a new file to the given inbox and will process the file.

## Upload mode: sync

When sync=true (default), the call will block and wait for the processing to complete.

If you have a custom output configured (this is set by contract.fit team),
passing mimetype *application/vnd.cf.custom* will allow you to get the custom output formatted result

Since it might yield inconsistent results if a timeout is raised while waiting,
it is recommended to use the **async** mode.

## Upload mode: async

When sync=false, the call will schedule the processing and return without waiting for completion.
It will return the document ID, so that the processed document can be retrieved at a later date.

**Permission required:** upload """,
    tags=['inbox_management', 'document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_documents_resource(inbox_id: str, file: UploadFile = ...):
    """
    Upload a new doc to the inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/documents/{inbox_id}/copy_inbox',
    description=""" Copy documents in the provided list to another inbox.

If the destination inbox is the same as the original inbox, the request will be aborted, no duplicates
will be created


**Permission required:** review """,
    tags=['document_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_document_copy_resource(inbox_id: str, body: DocumentIds = ...):
    """
    Copy documents to another inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/documents/{inbox_id}/move_inbox',
    description=""" Move documents in the provided list to another inbox.

If the destination inbox is the same as the original inbox, the request will be aborted.


**Permission required:** review """,
    tags=['document_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_document_move_resource(inbox_id: str, body: DocumentIds = ...):
    """
    Move documents to another inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/formats',
    description=""" Return the formats

**Deprecated**: display_name
**Deprecated**: default_format """,
    tags=['format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_formats_resource():
    """
    Get lists of format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/formats',
    description=""" Create an new format

**Deprecated**: display_name
**Deprecated**: default_format

**Permission required:** edit_format_settings """,
    tags=['format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_formats_resource(body: FormatModelPost):
    """
    Create format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/formats/document_types',
    description=""" **Permission required:** edit_format_settings """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_formats_doc_types_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get supported document_types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/formats/{format_id}',
    description=""" **WARNING** This will completely remove the documents, this is **not recoverable**

**Permission required:** edit_format_settings """,
    tags=['format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_format_resource(format_id: str):
    """
    Delete the format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/formats/{format_id}',
    description=""" Return the given format attributes

**Deprecated**: display_name
**Deprecated**: default_format

**Permission required:** edit_format_settings / review """,
    tags=['format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_format_resource(format_id: str):
    """
    Get format attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/formats/{format_id}',
    description=""" settings with the given attributes

**Deprecated**: display_name
**Deprecated**: default_format

**Permission required:** edit_format_settings """,
    tags=['format_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_format_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    format_id: str = ...,
    body: FormatModelPatch = ...,
):
    """
    Update the format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/formats/{scope}/tag_fields',
    description=""" Get the tag fields values bound to the given scope.

Scope can be an inbox or a project


**Permission required:** edit_format_settings / review """,
    tags=['data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_format_tag_fields_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), scope: str = ...
):
    """
    Get tags values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inboxes',
    description=""" Simply return the list of inboxes """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_inboxes_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get list of inboxes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inboxes',
    description=""" Create a new inbox in the given **project**

**Permission required:** create_inbox """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_inboxes_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: InboxModelPost = ...,
):
    """
    Create an inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/inboxes/{inbox_id}',
    description=""" Delete the given inbox.

**WARNING** This will completely remove the inbox, this is not recoverable """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_inbox_resource(inbox_id: str):
    """
    Delete an inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inboxes/{inbox_id}',
    description=""" Get the given inbox attributes

**Permission required:** view_list """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_inbox_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), inbox_id: str = ...
):
    """
    Get Inbox attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/inboxes/{inbox_id}',
    description=""" Update the given inbox with the provided arguments

**Permission required:** view_list """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_inbox_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    inbox_id: str = ...,
    body: InboxModelPatch = ...,
):
    """
    Update inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inboxes/{inbox_id}/document_versions',
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_inbox_document_versions_resource(inbox_id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/inboxes/{inbox_id}/documents',
    description=""" in the given inbox.

how parameter: if how == "FULL", we delete the entire document, including its source files
if how == "SOURCE_FILES", we only remove the (source) files and we set the archived flag. In practice this means
all information in the database (json) remains available, but you can no longer download / visualise the original document.

what parameter: if what == "DONE", we will only delete files which have status_data.feedback == True
if what == "ALL" we will delete all files

Start_date and end_date: when specified we will only delete files which are received after (respectively before) the timestamp

**WARNING** This will completely remove the documents, this is **not recoverable** """,
    tags=['document_management', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_inbox_document_resource(
    how: Optional[How] = 'FULL',
    what: Optional[What1] = 'ALL',
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
    inbox_id: str = ...,
):
    """
    Delete documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inboxes/{inbox_id}/documents',
    description=""" **Permission required:** view_list """,
    tags=['inbox_management', 'document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_inbox_document_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), inbox_id: str = ...
):
    """
    Get documents in the inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inboxes/{inbox_id}/paginated',
    description=""" **Permission required:** view_list """,
    tags=['inbox_management', 'document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_inbox_paginated_resource(
    page: Optional[int] = 1,
    per_page: Optional[int] = 20,
    start_receive_date: Optional[datetime_aliased] = None,
    end_receive_date: Optional[datetime_aliased] = None,
    order_by: Optional[str] = None,
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    inbox_id: str = ...,
):
    """
    Get paginated list of documents in the inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inboxes/{inbox_id}/reprocess',
    description=""" This endpoint schedule reprocessing for documents in the given inbox; this will call the async processing,
just like async document upload


**Permission required:** upload """,
    tags=['inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_inbox_reprocess_resource(
    name: Optional[str] = 'predicted',
    reviewer: Optional[Reviewer] = 'Machine',
    inbox_id: str = ...,
    file: UploadFile = ...,
):
    """
    Schedule inbox reprocessing
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/integrations/',
    description=""" Return the list of set up integrations

**Permission required:** read_integrations """,
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_integration_resources():
    """
    Get all integrations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/integrations/',
    description=""" Create a new integration. Each type of integration has its own initialization logic and thus may
yield suitable error codes depending on the underlying issue, such as credentials or connectivity issue.

**Permission required:** edit_integrations """,
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_integration_resources(body: IntegrationModelGet):
    """
    Create integration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/integrations/{integration_id}',
    description=""" Delete the given integration.

**WARNING** This will completely remove the integration, this is not recoverable

**Permission required:** edit_integrations """,
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_integration_resource(integration_id: str):
    """
    Delete an integration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/integrations/{integration_id}',
    description=""" Return the given integration attributes

**Permission required:** read_integrations """,
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_integration_resource(integration_id: str):
    """
    Get integration attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/integrations/{integration_id}',
    description=""" Update the given integration attributes

**Permission required:** edit_integrations """,
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_integration_resource(integration_id: str, body: IntegrationModelGet = ...):
    """
    Update integration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/integrations/{integration_id}/activate',
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_email_integration_activation_resource(secret: str, integration_id: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/predictor_settings',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['predictor_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_predictor_settings_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get all predictor settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/predictor_settings/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['predictor_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_predictor_setting_resource(scope: str):
    """
    Delete scoped predictor settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/predictor_settings/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['predictor_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_predictor_setting_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), scope: str = ...
):
    """
    Get scoped predictor settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/predictor_settings/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['predictor_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_predictor_setting_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    scope: str = ...,
    body: PredictorSettingModel = ...,
):
    """
    Update scoped predictor settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects',
    description=""" Return the list of projects in the organization


**Deprecated**: default_format """,
    tags=['project_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_projects_resource():
    """
    Get the list of projects
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects',
    description=""" Simply create a new project

**Deprecated**: default_format

**Permission required:** create_inbox """,
    tags=['project_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_projects_resource(body: ProjectModelPost):
    """
    Create a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project_id}',
    description=""" Delete the given project.

**WARNING** This will completely remove the project, this is not recoverable

**Permission required:** edit_format_settings """,
    tags=['project_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_project_resource(project_id: str):
    """
    Delete project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project_id}',
    description=""" Get the attributes of the given project


**Deprecated**: default_format """,
    tags=['project_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_project_resource(project_id: str):
    """
    Get project attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project_id}',
    description=""" Update the project attributes with the provided arguments


**Deprecated**: default_format

**Permission required:** edit_format_settings """,
    tags=['project_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_project_resource(project_id: str, body: ProjectModelPatch = ...):
    """
    Update project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports',
    description=""" Return the list of reports

**Permission required:** read_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_reports_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get all reports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reports',
    description=""" Create a new report

**Permission required:** edit_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_reports_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: ReportModelPost = ...,
):
    """
    Create report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reports/generate',
    description=""" **Note**: start_date and end_date filter on status update

**Permission required:** read_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_generate_report_resource(body: ReportModelFullGenerate):
    """
    Generate report based on input
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reports/{report_id}',
    description=""" Delete the given report.

**WARNING** This will completely remove the report, this is not recoverable

**Permission required:** edit_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_report_resource(report_id: str):
    """
    Delete a report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/{report_id}',
    description=""" Return report attributes

**Permission required:** read_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_report_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), report_id: str = ...
):
    """
    Get report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/reports/{report_id}',
    description=""" Modify the report with the given arguments

**Permission required:** edit_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_report_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    report_id: str = ...,
    body: ReportModelPost = ...,
):
    """
    Update report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reports/{report_id}/generate',
    description=""" **Note**: start_date and end_date filter on status update

**Permission required:** read_reports """,
    tags=['report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_generate_report_id_resource(
    delivery_method: DeliveryMethod1,
    email: Optional[str] = None,
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
    report_id: str = ...,
):
    """
    Generate report based on report id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles',
    description=""" Return the list of roles """,
    tags=['role_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_roles_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get all roles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/roles',
    description=""" Create a new role

**Permission required:** edit_users """,
    tags=['role_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_roles_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), body: RoleModelPost = ...
):
    """
    Create role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/roles/{role_id}',
    description=""" Delete the given role.

**WARNING** This will completely remove the role, this is not recoverable

**Permission required:** edit_users """,
    tags=['role_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_role_resource(role_id: str):
    """
    Delete a role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles/{role_id}',
    description=""" Return role attributes """,
    tags=['role_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_role_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), role_id: str = ...
):
    """
    Get role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/roles/{role_id}',
    description=""" Modify the role with the given arguments

**Permission required:** edit_users """,
    tags=['role_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_role_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    role_id: str = ...,
    body: RoleModelPatch = ...,
):
    """
    Update role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/rule_config',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_rule_configs_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get all rule configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rule_config/rule_entity/',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_debug_rule_entity_resource(body: Dictionary):
    """
    Get the regexes that are generated by the rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rule_config/rule_entity/{document_id}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['document_management', 'rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_debug_rule_entity_document_resource(document_id: str, body: Dictionary = ...):
    """
    Evaluate a rule on a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rule_config/where_to_search/{document_id}',
    description=""" Returns a list of strings per granularity. If no granularity is specified. It is considered to be the whole document

**Permission required:** edit_predictor_settings """,
    tags=['document_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_debug_where_to_search(document_id: str, body: Dictionary = ...):
    """
    Get the text a where_to_search specification will generate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/rule_config/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_rule_config_resource(scope: str):
    """
    Delete scoped rule config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/rule_config/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_rule_config_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), scope: str = ...
):
    """
    Get scoped rule config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/rule_config/{scope}',
    description=""" **Permission required:** edit_predictor_settings """,
    tags=['rule_config_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_rule_config_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    scope: str = ...,
    body: RuleConfigModel = ...,
):
    """
    Update scoped rule config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sampling_settings',
    description=""" **Permission required:** edit_sampling_settings / review """,
    tags=['sampling_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_setting_samplings_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get all sampling settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sampling_settings/{scope}',
    description=""" **Permission required:** edit_sampling_settings """,
    tags=['sampling_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_setting_sampling_resource(scope: str):
    """
    Delete scoped sampling settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sampling_settings/{scope}',
    description=""" **Permission required:** edit_sampling_settings / review """,
    tags=['sampling_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_setting_sampling_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), scope: str = ...
):
    """
    Get scoped sampling settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/sampling_settings/{scope}',
    description=""" **Permission required:** edit_sampling_settings """,
    tags=['sampling_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_setting_sampling_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    scope: str = ...,
    body: SamplingModelPatch = ...,
):
    """
    Update scoped sampling settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/settings/dashboard',
    description=""" Get the dashboard settings for the given scope (project or inbox) """,
    tags=['dashboard_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_dashboard_settings_atomic_resource(
    scope: Optional[str] = None,
    full: Optional[bool] = False,
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
):
    """
    Get scoped dashboard setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/settings/dashboard',
    description=""" Update the dashboard settings for the given scope (project or inbox)

**Permission required:** edit_dashboard_settings """,
    tags=['dashboard_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_dashboard_settings_atomic_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: DashboardSettingsModelPatch = ...,
):
    """
    Update scoped dashboard setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/settings/review',
    description=""" Get the review settings for the given scope (project or inbox) """,
    tags=['review_setting_management', 'data_retention_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_review_settings_atomic_resource(
    scope: Optional[str] = None,
    full: Optional[bool] = False,
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
):
    """
    Get scoped review setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/settings/review',
    description=""" Update the review settings for the given scope (project or inbox)

**Permission required:** edit_review_settings """,
    tags=['review_setting_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_review_settings_atomic_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: ReviewSettingsModelPatch = ...,
):
    """
    Update scoped review setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sso/config',
    tags=['release_and_version_info'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sso_config_resources(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sso/config',
    tags=['sso_configuration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_sso_config_resources(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: SsoConfigModel = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sso/config/{sso_config_id}',
    description=""" Return the given integration attributes

**Permission required:** edit_integrations """,
    tags=['sso_configuration_management', 'integration_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_sso_config_resources(sso_config_id: str):
    """
    Get integration attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sso/login',
    tags=['sso_configuration_management', 'authentication_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_oauth_login_resource(body: SsoModel):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/usage',
    tags=['inbox_management', 'statistics_retrieval'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_stats_resource(
    inbox_id: Optional[str] = None,
    start_date: str = '2023-01-31T13:36:39',
    end_date: str = '2023-03-02T13:36:39',
    excel_output: Optional[bool] = False,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{inbox_id}',
    description=""" Compute and return statistics on the given inbox, optionally restricted to a date range and a field.

Stats will return per field:
- accuracy
- precision
- f1 score
- recall

**Note** Depending on the date range and fields, computation might be intensive

**Permission required:** view_statistics """,
    tags=['statistics_retrieval', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_stats_resource(
    field_name: Optional[str] = None,
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
    version_name: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = None,
    inbox_id: str = ...,
):
    """
    Get inbox statistics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{inbox_id}/automation_blockers',
    description=""" **Permission required:** view_statistics """,
    tags=['statistics_retrieval', 'report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_automation_blockers_stats(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.252495',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.252527',
    version_name: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = 'predicted',
    include_detail: Optional[bool] = False,
    inbox_id: str = ...,
):
    """
    Get summary or details of automation blockers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stats/{inbox_id}/blue_dots',
    description=""" Compute and return the blue dots statistics, optionally restricted to date range, fields and versions

**Permission required:** submit """,
    tags=['inbox_management', 'statistics_retrieval'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_blue_dots_resource(inbox_id: str, file: UploadFile = ...):
    """
    Get the Blue Dots statistics for the inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{inbox_id}/evaluated_versions',
    description=""" If filter_on_version_date is True, the document
versions are filtered by timestamp, otherwise, documents are filtered by receive_time.

**Permission required:** view_statistics """,
    tags=['document_management', 'inbox_management', 'release_and_version_info'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_evaluated_versions(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.251355',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.251385',
    filter_versions: Optional[bool] = False,
    last_one_only: Optional[bool] = True,
    version_name: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = None,
    inbox_id: str = ...,
):
    """
    Get the documents with evaluated versions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{inbox_id}/processing',
    description=""" **This endpoint is in _preview_ and its interface may change.**

Compute statistics over the documents in the inbox. These stats include:
- mean
- min
- max
- standard deviation
- 50th percentile
- 95th percentile
- 99th percentile

Documents are grouped by their page count: this is currently the *only* supported group by attribute.

Documents can be further filter by any given start or end date: the filter will apply to the start
processing date, and *not* to the done date.

**Permission required:** view_statistics """,
    tags=['statistics_retrieval'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_processing_stats(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.251761',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.251794',
    group_by: Optional[str] = 'pages',
    inbox_id: str = ...,
):
    """
    Get processing runtime stats
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{inbox_id}/volume',
    tags=['statistics_retrieval', 'report_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_volume_stats(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.252098',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.252127',
    status: Optional[str] = 'to_review',
    user: Optional[str] = None,
    inbox_id: str = ...,
):
    """
    **Permission required:** view_statistics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{scope}/accuracy',
    description=""" **Permission required:** view_statistics """,
    tags=['statistics_retrieval', 'accuracy_and_stp_metrics', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_accuracy_resource(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.250494',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.250527',
    stp_files_only: Optional[bool] = False,
    stp_fields_only: Optional[bool] = False,
    version_name: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = None,
    filter_by: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = None,
    scope: str = ...,
):
    """
    Get the Accuracy counts on documents, sections and fields in the given inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/{scope}/stp',
    description=""" **Permission required:** view_statistics """,
    tags=['statistics_retrieval', 'accuracy_and_stp_metrics', 'inbox_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_stp_resource(
    start_date: Optional[datetime_aliased] = '2023-02-02T13:36:39.250021',
    end_date: Optional[datetime_aliased] = '2023-03-02T13:36:39.250091',
    version_name: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = 'predicted',
    filter_by: Optional[constr(pattern=r'^[A-z0-9_-]+$')] = None,
    scope: str = ...,
):
    """
    Get the STP counts on documents, sections and fields in the given inbox
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/style/custom.css',
    tags=['stylesheet_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_style_sheet_resource():
    """
    Get the custom CSS file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/style/custom.css',
    description=""" **Permission required:** edit_dashboard_settings """,
    tags=['logo_management', 'stylesheet_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_style_sheet_resource(file: UploadFile):
    """
    Upload the custom logo
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/style/logo.png',
    tags=['stylesheet_management', 'logo_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_style_logo_resource():
    """
    Get the custom logo
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/style/logo.png',
    description=""" **Permission required:** edit_dashboard_settings """,
    tags=['stylesheet_management', 'logo_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_style_logo_resource(file: UploadFile):
    """
    Upload the custom logo
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tenant',
    tags=['authentication_management', 'user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_tenant_resource():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/tenant/activate',
    tags=['tenant_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_activate_tenant_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    body: TenantModelPatch = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/threshold_settings',
    description=""" **Permission required:** read_thresholds_settings / review """,
    tags=['threshold_settings_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_settings_threshold_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields')
):
    """
    Get all thresholds settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/threshold_settings/{scope}',
    description=""" **Permission required:** edit_thresholds_settings """,
    tags=['threshold_settings_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_setting_threshold_resource(scope: str):
    """
    Delete the thresholds settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/threshold_settings/{scope}',
    description=""" **Permission required:** read_thresholds_settings / review """,
    tags=['threshold_settings_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_setting_threshold_resource(
    default: Optional[bool] = False,
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    scope: str = ...,
):
    """
    Get the scoped thresholds settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/threshold_settings/{scope}',
    description=""" **Permission required:** edit_thresholds_settings """,
    tags=['threshold_settings_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_setting_threshold_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    scope: str = ...,
    body: SettingThresholdModelPatch = ...,
):
    """
    Update the scoped thresholds settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" Return the list of users

**Permission required:** edit_users """,
    tags=['user_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_users_resource(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Get all users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users',
    description=""" Create a new user with the provided attributes and roles

**Permission required:** edit_users """,
    tags=['user_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_users_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), body: UserModelPost = ...
):
    """
    Create user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/me',
    description=""" Return user info of the authenticated used making the call """,
    tags=['user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me(x__fields: Optional[str] = Header(None, alias='X-Fields')):
    """
    Return info on the current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/me/change_password',
    description=""" Update the current authenticated user password """,
    tags=['authentication_management', 'user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_change_password(body: ChangePasswordModelPost):
    """
    Change the current user password
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/{user_id}',
    description=""" Delete the given user.

**WARNING** This will completely remove the user, this is not recoverable """,
    tags=['user_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_user_resource(user_id: str):
    """
    Delete a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}',
    description=""" Return user attribute

**Permission required:** edit_users """,
    tags=['user_management', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_user_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'), user_id: str = ...
):
    """
    Get user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/users/{user_id}',
    description=""" Update the given user with the provided attributes

**Permission required:** edit_users """,
    tags=['user_management'],
    security=[
        HTTPBasic(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def patch_user_resource(
    x__fields: Optional[str] = Header(None, alias='X-Fields'),
    user_id: str = ...,
    body: UserModelPatch = ...,
):
    """
    Update user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
